---
title: 操作系统之调度
author: kif
tags:
  - 操作系统
categories:
  - 学习笔记
abbrlink: 4be5
date: 2020-12-09 21:40:00
cover: https://kifimg.oss-cn-beijing.aliyuncs.com/imgforhexo/20201202142647.jpg
coverWidth: 1200
coverHeight: 750
---

# 调度

## 调度的基本概念

调度研究的问题：当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是调度研究的问题。

**举个有味道的例子：
现在有4个人要上厕所(他们几乎同时到达)，他们分别需要使用厕所3分钟、10分钟、1分钟、4分钟。但是他们面前只有一个厕所，而且厕所里面只有一个马桶，那我们应该怎么确定他们上厕所的顺序呢？
\**
我们有以下的方案：\**
\**1. 谁先来，谁就先用厕所。
\2. 谁需要使用的时间少，谁先用厕所。\**
\**
我们先说说第一种方案，这种方案很公平，谁先来谁先用，但是这样会产生一个问题。假如他们来的顺序是10分钟、4分钟、3分钟、1分钟，显然，采用这种方案的话，对于最后一个人，他上厕所1分钟要等17分钟，估计翔都憋不住了吧…
我们再说下第二种方案，采用这种方案的话，虽然没有第一种方案公平，但是这4个人的整体平均等待时间是最少的。(平均等待时间 = 每个人等待的时间的和 / 人数)\****



在上面的例子中，厕所就是资源，方案就是调度的规则，而调度就是安排他们上厕所。

**我们回到操作系统，在多道程序系统中，进程的数量往往是多于处理机个数的，这样就导致处理机不能并行的处理所有进程。处理机调度，就是从就绪队列中按照某种的算法选择一个进程并将处理机分配给它，以实现进程的并发运行。**

**操作系统的调度有三个层次，分别是高级调度、中级调度和低级调度。下面分别介绍它们。**



## 高级调度 (外存 --> 内存)

我们知道是计算机的内存空间是有限，所以有时操作系统无法将用户提交的作业全部放入内存 (在单道批系统时)，因此操作系统就需要确定某种算法，决定作业调度内存的顺序。
**高级调度，就是按某种算法在外存中处于后备队列的作业中挑选一个(或多个)作业，给它分配内存等必要资源，并建立相应的进程(建立PCB)，以使它(们)获得竞争处理机的权利。**
高级调度是外存与内存之间的调度。在这里，每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。**高级调度主要是指调入的问题**，因为只有调入的时机需要操作系统来确定，而调出的时机必然是作业运行结束后。
这种调度就好像刚刚的上厕所问题，厕所外的人处于后备队列，而高级调度的任务就类似把人从厕所外调入到厕所内。


![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20201209214206.png)

## 中级调度 (外存 --> 内存)

背景：在引入了虚拟存储技术之后，操作系统可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存稍有空闲时，操作系统再把它调回内存。
回顾一下，我们之前说过进程有几种状态，如 就绪态、阻塞态、运行态…，那被调到外存等待的进程处于什么状态呢？**这些进程会处于挂起态。**值得注意的，该进程的数据段和代码段会被调回外存，但PCB依旧会留在内存中的，并不会被调回外存，因为操作系统只有通过该进程的PCB，才能对其进行管理。**被挂起进程的PCB会被操作系统放到挂起队列中。**

**中级调度，就是决定将哪个挂起状态的进程从外存重新调回内存。**
**注意和高级调度区分，虽然同样是从外存调到内存，但高级调度是调入，中级调度是调回。**
由于一个进程可能会被多次调出、调回内存，因此**中级调度发生的频率要比高级调度的高。**

![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20201209214223.png)

### 补充：进程的挂起态与七状态模型

暂时调到外存等待的进程状态为挂起态。挂起态其实又可以进一步细分为就绪挂起、阻塞挂起两种状态，于是，五状态模型现在变成了七状态模型。
![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20201209214245.png) 

**注意：**

- **注意"挂起态"和"阻塞态"的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程实体(除PCB外)调到外存，而阻塞态的进程实体还留存在内存中。**
- **有的操作系统不只把挂起态分为阻塞挂起和就绪挂起，甚至会根据阻塞原因的不同把阻塞挂起态的进程进一步细分为多个队列。**



## 低级调度 (内存 --> CPU)

**低级调度的主要任务是按照某种规则从就绪队列中选取一个进程，将CPU分配给它。**低级调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置低级调度。而且低级调度的频率很高，一般几十毫秒一次。

![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20201209214129.png)



## 又是一个有味道的例子

**故事背景：现在有很多个人想上厕所，他们面前有一间厕所，厕所里面有三个马桶。**

**接下来，我们把厕所看作是内存，马桶看作是CPU，现在我们来看看这三种调度与这例子的类比。**

- **高级调度：研究怎么让还没进入过厕所的人进入厕所。(厕所外 --> 厕所内，之前一直在厕所外)**
- **中级调度：有的人进入了厕所，但是尿不出来，于是他们被赶了出去。中级调度就是研究怎么让这些被赶出去的人再次回到厕所。 (厕所外 --> 厕所内，之前进入过厕所)**
- **低级调度：研究怎么给厕所内的人分配马桶。(厕所内 --> 马桶上)**



## 总结

![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20201209214323.png)

# 调度的算法

### **先来先服务调度算法**（FCFS）

最简单的一个调度算法，就是非抢占式的**先来先服务（\*First Come First Severd, FCFS\*）算法**了。

![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20201209221801.png)

顾名思义，先来后到，**每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。**

这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。

FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。

### **最短作业优先调度算法**（SJF）

**最短作业优先（\*Shortest Job First, SJF\*）调度算法**同样也是顾名思义，它会**优先选择运行时间最短的进程来运行**，这有助于提高系统的吞吐量。

![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20201209221833.png)

这显然对长作业不利，很容易造成一种极端现象。

比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。

### **高响应比优先调度算法**（HRRN）

前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。

那么，**高响应比优先 （\*Highest Response Ratio Next, HRRN\*）调度算法**主要是权衡了短作业和长作业。

**每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行**，「响应比优先级」的计算公式：

![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20201209222002.png)

### **时间片轮转调度算法**（RR）

最古老、最简单、最公平且使用最广的算法就是**时间片轮转（\*Round Robin, RR\*）调度算法**。

![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20201210144712.png)

**每个进程被分配一个时间段，称为时间片（\*Quantum\*），即允许该进程在该时间段中运行。**

- 如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；
- 如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；

另外，时间片的长度就是一个很关键的点：

- 如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；
- 如果设得太长又可能引起对短作业进程的响应时间变长。将

通常时间片设为 `20ms~50ms` 通常是一个比较合理的折中值。

### **多级反馈队列调度算法**

**多级反馈队列（\*Multilevel Feedback Queue\*）调度算法**是「时间片轮转算法」和「最高优先级算法」的综合和发展。

顾名思义：

- 「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。
- 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；

![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20201210144819.png)

来看看，它是如何工作的：

- 设置了多个队列，赋予每个队列不同的优先级，每个**队列优先级从高到低**，同时**优先级越高时间片越短**；
- 新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；
- 当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；

可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的**兼顾了长短作业，同时有较好的响应时间。**

# 几种调度算法的比较：



![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20201210144950.png)

![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20201210145320.png)



参考文章：

[CPU调度算法总结](https://blog.csdn.net/u013616945/article/details/69569267)

[大厂面试爱问的「调度算法」，20 张图一举拿下](https://zhuanlan.zhihu.com/p/225162322)